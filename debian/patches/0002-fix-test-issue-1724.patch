Description: Fix 00429_http_bufferization
 Test was failing on stable release.
 .
 Backport of upstream #1757 pull request
Author: Vitaliy Lyudvichenko <ludv1x@yandex.ru>
Origin: Upstream
Last-Update: 2018-01-16
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/dbms/src/DataStreams/IProfilingBlockInputStream.cpp
+++ b/dbms/src/DataStreams/IProfilingBlockInputStream.cpp
@@ -48,7 +48,10 @@ Block IProfilingBlockInputStream::read()
         if (enabled_extremes)
             updateExtremes(res);
 
-        if (!checkLimits())
+        if (!checkTimeLimits())
+            limit_exceeded_need_break = true;
+
+        if (!checkDataSizeLimits())
             limit_exceeded_need_break = true;
 
         if (quota != nullptr)
@@ -140,43 +143,49 @@ void IProfilingBlockInputStream::updateE
 }
 
 
-bool IProfilingBlockInputStream::checkLimits()
+static bool handleOverflowMode(OverflowMode mode, const String & message, int code)
 {
-    auto handle_overflow_mode = [] (OverflowMode mode, const String & message, int code)
+    switch (mode)
     {
-        switch (mode)
-        {
-            case OverflowMode::THROW:
-                throw Exception(message, code);
-            case OverflowMode::BREAK:
-                return false;
-            default:
-                throw Exception("Logical error: unknown overflow mode", ErrorCodes::LOGICAL_ERROR);
-        }
-    };
+        case OverflowMode::THROW:
+            throw Exception(message, code);
+        case OverflowMode::BREAK:
+            return false;
+        default:
+            throw Exception("Logical error: unknown overflow mode", ErrorCodes::LOGICAL_ERROR);
+    }
+};
 
+bool IProfilingBlockInputStream::checkDataSizeLimits()
+{
     if (limits.mode == LIMITS_CURRENT)
     {
         /// Check current stream limitations (i.e. max_result_{rows,bytes})
 
         if (limits.max_rows_to_read && info.rows > limits.max_rows_to_read)
-            return handle_overflow_mode(limits.read_overflow_mode,
+            return handleOverflowMode(limits.read_overflow_mode,
                 std::string("Limit for result rows")
                     + " exceeded: read " + toString(info.rows)
                     + " rows, maximum: " + toString(limits.max_rows_to_read),
                 ErrorCodes::TOO_MUCH_ROWS);
 
         if (limits.max_bytes_to_read && info.bytes > limits.max_bytes_to_read)
-            return handle_overflow_mode(limits.read_overflow_mode,
+            return handleOverflowMode(limits.read_overflow_mode,
                 std::string("Limit for result bytes (uncompressed)")
                     + " exceeded: read " + toString(info.bytes)
                     + " bytes, maximum: " + toString(limits.max_bytes_to_read),
                 ErrorCodes::TOO_MUCH_BYTES);
     }
 
+    return true;
+}
+
+
+bool IProfilingBlockInputStream::checkTimeLimits()
+{
     if (limits.max_execution_time != 0
         && info.total_stopwatch.elapsed() > static_cast<UInt64>(limits.max_execution_time.totalMicroseconds()) * 1000)
-        return handle_overflow_mode(limits.timeout_overflow_mode,
+        return handleOverflowMode(limits.timeout_overflow_mode,
             "Timeout exceeded: elapsed " + toString(info.total_stopwatch.elapsedSeconds())
                 + " seconds, maximum: " + toString(limits.max_execution_time.totalMicroseconds() / 1000000.0),
             ErrorCodes::TIMEOUT_EXCEEDED);
@@ -399,5 +408,4 @@ void IProfilingBlockInputStream::collect
     progressImpl(Progress(0, 0, total_rows_approx));
 }
 
-
 }
--- a/dbms/src/DataStreams/IProfilingBlockInputStream.h
+++ b/dbms/src/DataStreams/IProfilingBlockInputStream.h
@@ -213,7 +213,8 @@ private:
     /** Check constraints and quotas.
       * But only those that can be tested within each separate source.
       */
-    bool checkLimits();
+    bool checkDataSizeLimits();
+    bool checkTimeLimits();
     void checkQuota(Block & block);
 
     /// Gather information about the approximate total number of rows from all children.
