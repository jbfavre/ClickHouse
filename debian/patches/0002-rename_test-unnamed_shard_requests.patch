Description: Fix misnamed tests
 Some tests don't work when running a standalone clickhouse server
 They should be skipped because we use the --no-shard option
 But need to be renamed
Author: Jean Baptiste Favre <debian@jbfavre.org>
Origin: other
Last-Update: 2017-09-28
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/dbms/tests/queries/0_stateless/00491_distributed_and_aliases_in_where_having.reference
+++ /dev/null
@@ -1 +0,0 @@
-0
--- a/dbms/tests/queries/0_stateless/00491_distributed_and_aliases_in_where_having.sql
+++ /dev/null
@@ -1 +0,0 @@
-SELECT dummy FROM (SELECT dummy, NOT dummy AS x FROM remote('127.0.0.{1,2}', system.one) GROUP BY dummy HAVING x);
--- /dev/null
+++ b/dbms/tests/queries/0_stateless/00491_shard_distributed_and_aliases_in_where_having.reference
@@ -0,0 +1 @@
+0
--- /dev/null
+++ b/dbms/tests/queries/0_stateless/00491_shard_distributed_and_aliases_in_where_having.sql
@@ -0,0 +1 @@
+SELECT dummy FROM (SELECT dummy, NOT dummy AS x FROM remote('127.0.0.{1,2}', system.one) GROUP BY dummy HAVING x);
--- a/dbms/tests/queries/0_stateless/00446_clear_column_in_partition.sql
+++ /dev/null
@@ -1,63 +0,0 @@
-DROP TABLE IF EXISTS test.clear_column;
-CREATE TABLE test.clear_column (d Date, num Int64, str String) ENGINE = MergeTree(d, d, 8192);
-
-INSERT INTO test.clear_column VALUES ('2016-12-12', 1, 'a'), ('2016-11-12', 2, 'b');
-
-SELECT num, str FROM test.clear_column ORDER BY num;
-ALTER TABLE test.clear_column CLEAR COLUMN num IN PARTITION '201612';
-SELECT num, str FROM test.clear_column ORDER BY num;
-
-DROP TABLE test.clear_column;
-
--- Replicated case
-
-DROP TABLE IF EXISTS test.clear_column1;
-DROP TABLE IF EXISTS test.clear_column2;
-CREATE TABLE test.clear_column1 (d Date, i Int64) ENGINE = ReplicatedMergeTree('/clickhouse/tables/test/clear_column', '1', d, d, 8192);
-CREATE TABLE test.clear_column2 (d Date, i Int64) ENGINE = ReplicatedMergeTree('/clickhouse/tables/test/clear_column', '2', d, d, 8192);
-
-INSERT INTO test.clear_column1 (d) VALUES ('2000-01-01'), ('2000-02-01');
-
-SET replication_alter_partitions_sync=2;
-ALTER TABLE test.clear_column1 ADD COLUMN s String;
-ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200001';
-
-INSERT INTO test.clear_column1 VALUES ('2000-01-01', 1, 'a'), ('2000-02-01', 2, 'b');
-INSERT INTO test.clear_column1 VALUES ('2000-01-01', 3, 'c'), ('2000-02-01', 4, 'd');
-
-SELECT 'all';
-SELECT * FROM test.clear_column1 ORDER BY d, i, s;
-
-SELECT 'w/o i 1';
-ALTER TABLE test.clear_column1 CLEAR COLUMN i IN PARTITION '200001';
-SELECT * FROM test.clear_column2 ORDER BY d, i, s;
-
-SELECT 'w/o is 1';
-ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200001';
-SELECT * FROM test.clear_column2 ORDER BY d, i, s;
-
-SELECT 'w/o is 12';
-ALTER TABLE test.clear_column1 CLEAR COLUMN i IN PARTITION '200002';
-ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200002';
-SELECT DISTINCT * FROM test.clear_column2 ORDER BY d, i, s;
-SELECT DISTINCT * FROM test.clear_column2 ORDER BY d, i, s;
-
-SELECT 'sizes';
-SELECT sum(data_uncompressed_bytes) FROM system.columns WHERE database='test' AND table LIKE 'clear_column_' AND (name = 'i' OR name = 's') GROUP BY table;
-
--- double call should be OK
-ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200001';
-ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200002';
-
--- clear column in empty partition should be Ok
-ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200012', CLEAR COLUMN i IN PARTITION '200012';
--- Drop empty partition also Ok
-ALTER TABLE test.clear_column1 DROP PARTITION '200012', DROP PARTITION '200011';
-
-
--- check optimize for non-leader replica (it is not related with CLEAR COLUMN)
-OPTIMIZE TABLE test.clear_column1;
-OPTIMIZE TABLE test.clear_column2;
-
-DROP TABLE IF EXISTS test.clear_column1;
-DROP TABLE IF EXISTS test.clear_column2;
--- /dev/null
+++ b/dbms/tests/queries/0_stateless/00446_shard_clear_column_in_partition.sql
@@ -0,0 +1,63 @@
+DROP TABLE IF EXISTS test.clear_column;
+CREATE TABLE test.clear_column (d Date, num Int64, str String) ENGINE = MergeTree(d, d, 8192);
+
+INSERT INTO test.clear_column VALUES ('2016-12-12', 1, 'a'), ('2016-11-12', 2, 'b');
+
+SELECT num, str FROM test.clear_column ORDER BY num;
+ALTER TABLE test.clear_column CLEAR COLUMN num IN PARTITION '201612';
+SELECT num, str FROM test.clear_column ORDER BY num;
+
+DROP TABLE test.clear_column;
+
+-- Replicated case
+
+DROP TABLE IF EXISTS test.clear_column1;
+DROP TABLE IF EXISTS test.clear_column2;
+CREATE TABLE test.clear_column1 (d Date, i Int64) ENGINE = ReplicatedMergeTree('/clickhouse/tables/test/clear_column', '1', d, d, 8192);
+CREATE TABLE test.clear_column2 (d Date, i Int64) ENGINE = ReplicatedMergeTree('/clickhouse/tables/test/clear_column', '2', d, d, 8192);
+
+INSERT INTO test.clear_column1 (d) VALUES ('2000-01-01'), ('2000-02-01');
+
+SET replication_alter_partitions_sync=2;
+ALTER TABLE test.clear_column1 ADD COLUMN s String;
+ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200001';
+
+INSERT INTO test.clear_column1 VALUES ('2000-01-01', 1, 'a'), ('2000-02-01', 2, 'b');
+INSERT INTO test.clear_column1 VALUES ('2000-01-01', 3, 'c'), ('2000-02-01', 4, 'd');
+
+SELECT 'all';
+SELECT * FROM test.clear_column1 ORDER BY d, i, s;
+
+SELECT 'w/o i 1';
+ALTER TABLE test.clear_column1 CLEAR COLUMN i IN PARTITION '200001';
+SELECT * FROM test.clear_column2 ORDER BY d, i, s;
+
+SELECT 'w/o is 1';
+ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200001';
+SELECT * FROM test.clear_column2 ORDER BY d, i, s;
+
+SELECT 'w/o is 12';
+ALTER TABLE test.clear_column1 CLEAR COLUMN i IN PARTITION '200002';
+ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200002';
+SELECT DISTINCT * FROM test.clear_column2 ORDER BY d, i, s;
+SELECT DISTINCT * FROM test.clear_column2 ORDER BY d, i, s;
+
+SELECT 'sizes';
+SELECT sum(data_uncompressed_bytes) FROM system.columns WHERE database='test' AND table LIKE 'clear_column_' AND (name = 'i' OR name = 's') GROUP BY table;
+
+-- double call should be OK
+ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200001';
+ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200002';
+
+-- clear column in empty partition should be Ok
+ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200012', CLEAR COLUMN i IN PARTITION '200012';
+-- Drop empty partition also Ok
+ALTER TABLE test.clear_column1 DROP PARTITION '200012', DROP PARTITION '200011';
+
+
+-- check optimize for non-leader replica (it is not related with CLEAR COLUMN)
+OPTIMIZE TABLE test.clear_column1;
+OPTIMIZE TABLE test.clear_column2;
+
+DROP TABLE IF EXISTS test.clear_column1;
+DROP TABLE IF EXISTS test.clear_column2;
--- a/dbms/tests/queries/0_stateless/00446_clear_column_in_partition.reference
+++ /dev/null
@@ -1,33 +0,0 @@
-1	a
-2	b
-0	a
-2	b
-all
-2000-01-01	0	
-2000-01-01	1	a
-2000-01-01	3	c
-2000-02-01	0	
-2000-02-01	2	b
-2000-02-01	4	d
-w/o i 1
-2000-01-01	0	
-2000-01-01	0	a
-2000-01-01	0	c
-2000-02-01	0	
-2000-02-01	2	b
-2000-02-01	4	d
-w/o is 1
-2000-01-01	0	
-2000-01-01	0	
-2000-01-01	0	
-2000-02-01	0	
-2000-02-01	2	b
-2000-02-01	4	d
-w/o is 12
-2000-01-01	0	
-2000-02-01	0	
-2000-01-01	0	
-2000-02-01	0	
-sizes
-0
-0
--- /dev/null
+++ b/dbms/tests/queries/0_stateless/00446_shard_clear_column_in_partition.reference
@@ -0,0 +1,33 @@
+1	a
+2	b
+0	a
+2	b
+all
+2000-01-01	0	
+2000-01-01	1	a
+2000-01-01	3	c
+2000-02-01	0	
+2000-02-01	2	b
+2000-02-01	4	d
+w/o i 1
+2000-01-01	0	
+2000-01-01	0	a
+2000-01-01	0	c
+2000-02-01	0	
+2000-02-01	2	b
+2000-02-01	4	d
+w/o is 1
+2000-01-01	0	
+2000-01-01	0	
+2000-01-01	0	
+2000-02-01	0	
+2000-02-01	2	b
+2000-02-01	4	d
+w/o is 12
+2000-01-01	0	
+2000-02-01	0	
+2000-01-01	0	
+2000-02-01	0	
+sizes
+0
+0
--- a/dbms/tests/queries/0_stateless/00446_clear_column_in_partition_concurrent.reference
+++ /dev/null
@@ -1,4 +0,0 @@
-2000-01-01	0	
-2000-02-01	0	
-2000-01-01	0	
-2000-02-01	0	
--- a/dbms/tests/queries/0_stateless/00446_clear_column_in_partition_concurrent.sh
+++ /dev/null
@@ -1,35 +0,0 @@
-#!/bin/bash
-
-ch="clickhouse-client --stacktrace -q"
-
-$ch "DROP TABLE IF EXISTS test.clear_column1"
-$ch "DROP TABLE IF EXISTS test.clear_column2"
-$ch "CREATE TABLE test.clear_column1 (d Date, i Int64, s String) ENGINE = ReplicatedMergeTree('/clickhouse/tables/test/clear_column', '1', d, d, 8192)"
-$ch "CREATE TABLE test.clear_column2 (d Date, i Int64, s String) ENGINE = ReplicatedMergeTree('/clickhouse/tables/test/clear_column', '2', d, d, 8192)"
-
-$ch "ALTER TABLE test.clear_column1 CLEAR COLUMN VasyaUnexistingColumn IN PARTITION '200001'" 1>/dev/null 2>/dev/null
-rc=$?
-if [ $rc -eq 0 ]; then
-    echo "An unexisisting column was ALTERed. Code: $rc"
-    exit -1
-fi
-
-set -e
-$ch "INSERT INTO test.clear_column1 VALUES ('2000-01-01', 1, 'a'), ('2000-02-01', 2, 'b')"
-$ch "INSERT INTO test.clear_column1 VALUES ('2000-01-01', 3, 'c'), ('2000-02-01', 4, 'd')"
-
-for i in `seq 3`; do
-    $ch "INSERT INTO test.clear_column1 VALUES ('2000-02-01', 0, ''), ('2000-02-01', 0, '')" & # insert into the same partition
-    $ch "ALTER TABLE test.clear_column1 CLEAR COLUMN i IN PARTITION '200001'" --replication_alter_partitions_sync=2 &
-    $ch "ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200001'" --replication_alter_partitions_sync=2 &
-    $ch "ALTER TABLE test.clear_column1 CLEAR COLUMN i IN PARTITION '200002'" --replication_alter_partitions_sync=2 &
-    $ch "ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200002'" --replication_alter_partitions_sync=2 &
-    $ch "INSERT INTO test.clear_column1 VALUES ('2000-03-01', 3, 'c'), ('2000-03-01', 4, 'd')" & # insert into other partition
-done
-wait
-
-$ch "SELECT DISTINCT * FROM test.clear_column1 WHERE d != toDate('2000-03-01') ORDER BY d, i, s"
-$ch "SELECT DISTINCT * FROM test.clear_column2 WHERE d != toDate('2000-03-01') ORDER BY d, i, s"
-
-#$ch "DROP TABLE IF EXISTS test.clear_column1"
-#$ch "DROP TABLE IF EXISTS test.clear_column2"
--- /dev/null
+++ b/dbms/tests/queries/0_stateless/00446_shard_clear_column_in_partition_concurrent.reference
@@ -0,0 +1,4 @@
+2000-01-01	0	
+2000-02-01	0	
+2000-01-01	0	
+2000-02-01	0	
--- /dev/null
+++ b/dbms/tests/queries/0_stateless/00446_shard_clear_column_in_partition_concurrent.sh
@@ -0,0 +1,35 @@
+#!/bin/bash
+
+ch="clickhouse-client --stacktrace -q"
+
+$ch "DROP TABLE IF EXISTS test.clear_column1"
+$ch "DROP TABLE IF EXISTS test.clear_column2"
+$ch "CREATE TABLE test.clear_column1 (d Date, i Int64, s String) ENGINE = ReplicatedMergeTree('/clickhouse/tables/test/clear_column', '1', d, d, 8192)"
+$ch "CREATE TABLE test.clear_column2 (d Date, i Int64, s String) ENGINE = ReplicatedMergeTree('/clickhouse/tables/test/clear_column', '2', d, d, 8192)"
+
+$ch "ALTER TABLE test.clear_column1 CLEAR COLUMN VasyaUnexistingColumn IN PARTITION '200001'" 1>/dev/null 2>/dev/null
+rc=$?
+if [ $rc -eq 0 ]; then
+    echo "An unexisisting column was ALTERed. Code: $rc"
+    exit -1
+fi
+
+set -e
+$ch "INSERT INTO test.clear_column1 VALUES ('2000-01-01', 1, 'a'), ('2000-02-01', 2, 'b')"
+$ch "INSERT INTO test.clear_column1 VALUES ('2000-01-01', 3, 'c'), ('2000-02-01', 4, 'd')"
+
+for i in `seq 3`; do
+    $ch "INSERT INTO test.clear_column1 VALUES ('2000-02-01', 0, ''), ('2000-02-01', 0, '')" & # insert into the same partition
+    $ch "ALTER TABLE test.clear_column1 CLEAR COLUMN i IN PARTITION '200001'" --replication_alter_partitions_sync=2 &
+    $ch "ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200001'" --replication_alter_partitions_sync=2 &
+    $ch "ALTER TABLE test.clear_column1 CLEAR COLUMN i IN PARTITION '200002'" --replication_alter_partitions_sync=2 &
+    $ch "ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200002'" --replication_alter_partitions_sync=2 &
+    $ch "INSERT INTO test.clear_column1 VALUES ('2000-03-01', 3, 'c'), ('2000-03-01', 4, 'd')" & # insert into other partition
+done
+wait
+
+$ch "SELECT DISTINCT * FROM test.clear_column1 WHERE d != toDate('2000-03-01') ORDER BY d, i, s"
+$ch "SELECT DISTINCT * FROM test.clear_column2 WHERE d != toDate('2000-03-01') ORDER BY d, i, s"
+
+#$ch "DROP TABLE IF EXISTS test.clear_column1"
+#$ch "DROP TABLE IF EXISTS test.clear_column2"
--- a/dbms/tests/queries/0_stateless/00113_group_array.reference
+++ /dev/null
@@ -1,90 +0,0 @@
-0	100
-1	100
-2	100
-3	100
-4	100
-5	100
-6	100
-7	100
-8	100
-9	100
-
-0	1000000
-
-21
-41
-1000000	500000500000	1000000
-1000000	500000500000	1000000
-1000000	500000500000	1000000	500000500000
-1000000	500000500000	1000000	500000500000
-2000000	1000001000000	1000000
-2000000	1000001000000	1000000
-2000000	1000001000000	1000000	1000001000000
-
-512	1	512	512
-1024	1	1024	1024
-2048	1	1024	2048
-4096	1	1024	4096
-8192	1	1024	8192
-16384	1	1024	16384
-32768	1	1024	32768
-65536	1	1024	65536
-131072	1	1024	65536
-262144	1	1024	65536
-524288	1	1024	65536
-512	1	512	512
-1024	1	1024	1024
-2048	1	1024	2048
-4096	1	1024	4096
-8192	1	1024	8192
-16384	1	1024	16384
-32768	1	1024	32768
-65536	1	1024	65536
-131072	1	1024	65536
-262144	1	1024	65536
-524288	1	1024	65536
-512	1	512	512
-1024	1	1024	1024
-2048	1	1024	2048
-4096	1	1024	4096
-8192	1	1024	8192
-16384	1	1024	16384
-32768	1	1024	32768
-65536	1	1024	65536
-131072	1	1024	65536
-262144	1	1024	65536
-524288	1	1024	65536
-
-512	1	1024	1024
-1024	1	1500	2048
-2048	1	1500	4096
-4096	1	1500	8192
-8192	1	1500	16384
-16384	1	1500	32768
-32768	1	1500	65536
-65536	1	1500	70000
-131072	1	1500	70000
-262144	1	1500	70000
-524288	1	1500	70000
-512	1	1024	1024
-1024	1	1500	2048
-2048	1	1500	4096
-4096	1	1500	8192
-8192	1	1500	16384
-16384	1	1500	32768
-32768	1	1500	65536
-65536	1	1500	70000
-131072	1	1500	70000
-262144	1	1500	70000
-524288	1	1500	70000
-512	1	1024	1024
-1024	1	1500	2048
-2048	1	1500	4096
-4096	1	1500	8192
-8192	1	1500	16384
-16384	1	1500	32768
-32768	1	1500	65536
-65536	1	1500	70000
-131072	1	1500	70000
-262144	1	1500	70000
-524288	1	1500	70000
--- a/dbms/tests/queries/0_stateless/00113_group_array.sql
+++ /dev/null
@@ -1,37 +0,0 @@
-SELECT intDiv(number, 100) AS k, length(groupArray(number)) FROM (SELECT * FROM system.numbers LIMIT 1000000) GROUP BY k WITH TOTALS ORDER BY k LIMIT 10;
-
-SELECT '';
-SELECT length(toString(groupArrayState(toDate(number)))) FROM (SELECT * FROM system.numbers LIMIT 10);
-SELECT length(toString(groupArrayState(toDateTime(number)))) FROM (SELECT * FROM system.numbers LIMIT 10);
-
-DROP TABLE IF EXISTS test.numbers_mt;
-CREATE TABLE test.numbers_mt (number UInt64) ENGINE = Log;
-INSERT INTO test.numbers_mt SELECT * FROM system.numbers LIMIT 1, 1000000;
-
-SELECT count(), sum(ns), max(ns) FROM (SELECT intDiv(number, 100) AS k, groupArray(number) AS ns FROM test.numbers_mt GROUP BY k) ARRAY JOIN ns;
-SELECT count(), sum(toUInt64(ns)), max(toUInt64(ns)) FROM (SELECT intDiv(number, 100) AS k, groupArray(toString(number)) AS ns FROM test.numbers_mt GROUP BY k) ARRAY JOIN ns;
-SELECT count(), sum(toUInt64(ns[1])), max(toUInt64(ns[1])), sum(toUInt64(ns[2]))/10 FROM (SELECT intDiv(number, 100) AS k, groupArray([toString(number), toString(number*10)]) AS ns FROM test.numbers_mt GROUP BY k) ARRAY JOIN ns;
-SELECT count(), sum(ns[1]), max(ns[1]), sum(ns[2])/10 FROM (SELECT intDiv(number, 100) AS k, groupArray([number, number*10]) AS ns FROM test.numbers_mt GROUP BY k) ARRAY JOIN ns;
-
-SELECT count(), sum(ns), max(ns) FROM (SELECT intDiv(number, 100) AS k, groupArray(number) AS ns FROM remote('127.0.0.{1,2}', 'test', 'numbers_mt') GROUP BY k) ARRAY JOIN ns;
-SELECT count(), sum(toUInt64(ns)), max(toUInt64(ns)) FROM (SELECT intDiv(number, 100) AS k, groupArray(toString(number)) AS ns FROM remote('127.0.0.{1,2}', 'test', 'numbers_mt') GROUP BY k) ARRAY JOIN ns;
-SELECT count(), sum(toUInt64(ns[1])), max(toUInt64(ns[1])), sum(toUInt64(ns[2]))/10 FROM (SELECT intDiv(number, 100) AS k, groupArray([toString(number), toString(number*10)]) AS ns FROM remote('127.0.0.{1,2}', 'test', 'numbers_mt') GROUP BY k) ARRAY JOIN ns;
-
-DROP TABLE test.numbers_mt;
-CREATE TABLE test.numbers_mt (number UInt64) ENGINE = Log;
-INSERT INTO test.numbers_mt SELECT * FROM system.numbers LIMIT 1, 1048575;
-
-SELECT '';
-SELECT roundToExp2(number) AS k, length(groupArray(1)(number AS i)), length(groupArray(1024)(i)), length(groupArray(65536)(i)) AS s FROM test.numbers_mt GROUP BY k ORDER BY k LIMIT 9, 11;
-SELECT roundToExp2(number) AS k, length(groupArray(1)(hex(number) AS i)), length(groupArray(1024)(i)), length(groupArray(65536)(i)) AS s FROM test.numbers_mt GROUP BY k ORDER BY k LIMIT 9, 11;
-SELECT roundToExp2(number) AS k, length(groupArray(1)([hex(number)] AS i)), length(groupArray(1024)(i)), length(groupArray(65536)(i)) AS s FROM test.numbers_mt GROUP BY k ORDER BY k LIMIT 9, 11;
-
-SELECT '';
-SELECT roundToExp2(number) AS k, length(groupArray(1)(number AS i)), length(groupArray(1500)(i)), length(groupArray(70000)(i)) AS s FROM remote('127.0.0.{1,2}', 'test', 'numbers_mt') GROUP BY k ORDER BY k LIMIT 9, 11;
-SELECT roundToExp2(number) AS k, length(groupArray(1)(hex(number) AS i)), length(groupArray(1500)(i)), length(groupArray(70000)(i)) AS s FROM remote('127.0.0.{1,2}', 'test', 'numbers_mt') GROUP BY k ORDER BY k LIMIT 9, 11;
-SELECT roundToExp2(number) AS k, length(groupArray(1)([hex(number)] AS i)), length(groupArray(1500)(i)), length(groupArray(70000)(i)) AS s FROM remote('127.0.0.{1,2}', 'test', 'numbers_mt') GROUP BY k ORDER BY k LIMIT 9, 11;
-
-DROP TABLE test.numbers_mt;
-
--- Check binary compability:
--- clickhouse-client -h old -q "SELECT arrayReduce('groupArrayState', [['1'], ['22'], ['333']]) FORMAT RowBinary" | clickhouse-local --input-format RowBinary --structure "d AggregateFunction(groupArray2, Array(String))" -q "SELECT groupArray2Merge(d) FROM table"
--- /dev/null
+++ b/dbms/tests/queries/0_stateless/00113_shard_group_array.reference
@@ -0,0 +1,90 @@
+0	100
+1	100
+2	100
+3	100
+4	100
+5	100
+6	100
+7	100
+8	100
+9	100
+
+0	1000000
+
+21
+41
+1000000	500000500000	1000000
+1000000	500000500000	1000000
+1000000	500000500000	1000000	500000500000
+1000000	500000500000	1000000	500000500000
+2000000	1000001000000	1000000
+2000000	1000001000000	1000000
+2000000	1000001000000	1000000	1000001000000
+
+512	1	512	512
+1024	1	1024	1024
+2048	1	1024	2048
+4096	1	1024	4096
+8192	1	1024	8192
+16384	1	1024	16384
+32768	1	1024	32768
+65536	1	1024	65536
+131072	1	1024	65536
+262144	1	1024	65536
+524288	1	1024	65536
+512	1	512	512
+1024	1	1024	1024
+2048	1	1024	2048
+4096	1	1024	4096
+8192	1	1024	8192
+16384	1	1024	16384
+32768	1	1024	32768
+65536	1	1024	65536
+131072	1	1024	65536
+262144	1	1024	65536
+524288	1	1024	65536
+512	1	512	512
+1024	1	1024	1024
+2048	1	1024	2048
+4096	1	1024	4096
+8192	1	1024	8192
+16384	1	1024	16384
+32768	1	1024	32768
+65536	1	1024	65536
+131072	1	1024	65536
+262144	1	1024	65536
+524288	1	1024	65536
+
+512	1	1024	1024
+1024	1	1500	2048
+2048	1	1500	4096
+4096	1	1500	8192
+8192	1	1500	16384
+16384	1	1500	32768
+32768	1	1500	65536
+65536	1	1500	70000
+131072	1	1500	70000
+262144	1	1500	70000
+524288	1	1500	70000
+512	1	1024	1024
+1024	1	1500	2048
+2048	1	1500	4096
+4096	1	1500	8192
+8192	1	1500	16384
+16384	1	1500	32768
+32768	1	1500	65536
+65536	1	1500	70000
+131072	1	1500	70000
+262144	1	1500	70000
+524288	1	1500	70000
+512	1	1024	1024
+1024	1	1500	2048
+2048	1	1500	4096
+4096	1	1500	8192
+8192	1	1500	16384
+16384	1	1500	32768
+32768	1	1500	65536
+65536	1	1500	70000
+131072	1	1500	70000
+262144	1	1500	70000
+524288	1	1500	70000
--- /dev/null
+++ b/dbms/tests/queries/0_stateless/00113_shard_group_array.sql
@@ -0,0 +1,37 @@
+SELECT intDiv(number, 100) AS k, length(groupArray(number)) FROM (SELECT * FROM system.numbers LIMIT 1000000) GROUP BY k WITH TOTALS ORDER BY k LIMIT 10;
+
+SELECT '';
+SELECT length(toString(groupArrayState(toDate(number)))) FROM (SELECT * FROM system.numbers LIMIT 10);
+SELECT length(toString(groupArrayState(toDateTime(number)))) FROM (SELECT * FROM system.numbers LIMIT 10);
+
+DROP TABLE IF EXISTS test.numbers_mt;
+CREATE TABLE test.numbers_mt (number UInt64) ENGINE = Log;
+INSERT INTO test.numbers_mt SELECT * FROM system.numbers LIMIT 1, 1000000;
+
+SELECT count(), sum(ns), max(ns) FROM (SELECT intDiv(number, 100) AS k, groupArray(number) AS ns FROM test.numbers_mt GROUP BY k) ARRAY JOIN ns;
+SELECT count(), sum(toUInt64(ns)), max(toUInt64(ns)) FROM (SELECT intDiv(number, 100) AS k, groupArray(toString(number)) AS ns FROM test.numbers_mt GROUP BY k) ARRAY JOIN ns;
+SELECT count(), sum(toUInt64(ns[1])), max(toUInt64(ns[1])), sum(toUInt64(ns[2]))/10 FROM (SELECT intDiv(number, 100) AS k, groupArray([toString(number), toString(number*10)]) AS ns FROM test.numbers_mt GROUP BY k) ARRAY JOIN ns;
+SELECT count(), sum(ns[1]), max(ns[1]), sum(ns[2])/10 FROM (SELECT intDiv(number, 100) AS k, groupArray([number, number*10]) AS ns FROM test.numbers_mt GROUP BY k) ARRAY JOIN ns;
+
+SELECT count(), sum(ns), max(ns) FROM (SELECT intDiv(number, 100) AS k, groupArray(number) AS ns FROM remote('127.0.0.{1,2}', 'test', 'numbers_mt') GROUP BY k) ARRAY JOIN ns;
+SELECT count(), sum(toUInt64(ns)), max(toUInt64(ns)) FROM (SELECT intDiv(number, 100) AS k, groupArray(toString(number)) AS ns FROM remote('127.0.0.{1,2}', 'test', 'numbers_mt') GROUP BY k) ARRAY JOIN ns;
+SELECT count(), sum(toUInt64(ns[1])), max(toUInt64(ns[1])), sum(toUInt64(ns[2]))/10 FROM (SELECT intDiv(number, 100) AS k, groupArray([toString(number), toString(number*10)]) AS ns FROM remote('127.0.0.{1,2}', 'test', 'numbers_mt') GROUP BY k) ARRAY JOIN ns;
+
+DROP TABLE test.numbers_mt;
+CREATE TABLE test.numbers_mt (number UInt64) ENGINE = Log;
+INSERT INTO test.numbers_mt SELECT * FROM system.numbers LIMIT 1, 1048575;
+
+SELECT '';
+SELECT roundToExp2(number) AS k, length(groupArray(1)(number AS i)), length(groupArray(1024)(i)), length(groupArray(65536)(i)) AS s FROM test.numbers_mt GROUP BY k ORDER BY k LIMIT 9, 11;
+SELECT roundToExp2(number) AS k, length(groupArray(1)(hex(number) AS i)), length(groupArray(1024)(i)), length(groupArray(65536)(i)) AS s FROM test.numbers_mt GROUP BY k ORDER BY k LIMIT 9, 11;
+SELECT roundToExp2(number) AS k, length(groupArray(1)([hex(number)] AS i)), length(groupArray(1024)(i)), length(groupArray(65536)(i)) AS s FROM test.numbers_mt GROUP BY k ORDER BY k LIMIT 9, 11;
+
+SELECT '';
+SELECT roundToExp2(number) AS k, length(groupArray(1)(number AS i)), length(groupArray(1500)(i)), length(groupArray(70000)(i)) AS s FROM remote('127.0.0.{1,2}', 'test', 'numbers_mt') GROUP BY k ORDER BY k LIMIT 9, 11;
+SELECT roundToExp2(number) AS k, length(groupArray(1)(hex(number) AS i)), length(groupArray(1500)(i)), length(groupArray(70000)(i)) AS s FROM remote('127.0.0.{1,2}', 'test', 'numbers_mt') GROUP BY k ORDER BY k LIMIT 9, 11;
+SELECT roundToExp2(number) AS k, length(groupArray(1)([hex(number)] AS i)), length(groupArray(1500)(i)), length(groupArray(70000)(i)) AS s FROM remote('127.0.0.{1,2}', 'test', 'numbers_mt') GROUP BY k ORDER BY k LIMIT 9, 11;
+
+DROP TABLE test.numbers_mt;
+
+-- Check binary compability:
+-- clickhouse-client -h old -q "SELECT arrayReduce('groupArrayState', [['1'], ['22'], ['333']]) FORMAT RowBinary" | clickhouse-local --input-format RowBinary --structure "d AggregateFunction(groupArray2, Array(String))" -q "SELECT groupArray2Merge(d) FROM table"
